%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
\edef\sphinxdqmaybe{\ifdefined\DeclareUnicodeCharacterAsOptional\string"\fi}
  \DeclareUnicodeCharacter{\sphinxdqmaybe00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}
\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\addto\captionsenglish{\renewcommand{\figurename}{Fig.}}
\addto\captionsenglish{\renewcommand{\tablename}{Table}}
\addto\captionsenglish{\renewcommand{\literalblockname}{Listing}}

\addto\captionsenglish{\renewcommand{\literalblockcontinuedname}{continued from previous page}}
\addto\captionsenglish{\renewcommand{\literalblockcontinuesname}{continues on next page}}
\addto\captionsenglish{\renewcommand{\sphinxnonalphabeticalgroupname}{Non-alphabetical}}
\addto\captionsenglish{\renewcommand{\sphinxsymbolsname}{Symbols}}
\addto\captionsenglish{\renewcommand{\sphinxnumbersname}{Numbers}}

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{1}



\title{Nanostream Documentation}
\date{Oct 12, 2018}
\release{0.1}
\author{Zachary Ernst}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\maketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}



\chapter{Overview}
\label{\detokenize{overview:overview}}\label{\detokenize{overview::doc}}

\section{What is it? Why is it?}
\label{\detokenize{overview:what-is-it-why-is-it}}
We love stream processing. It’s a great model for lots of work,
especially ETL. There are excellent stream processing tools such as
Spark, Flink, and Storm. They’re designed for handling huge amounts of
Big Data(tm). But they carry a lot of overhead because they’re Big
Data(tm) tools.

Most of our data problems are not Big Data(tm). They’re also not Small
Data. They’re Medium Data \textendash{} that is, data that’s big enough to require
some planning, but not so big as to justify the infrastructure and
complexity overhead that come with Spark and its cousins.

NanoStream lets you deploy a streaming application with no overhead.
It’s entirely self-contained, and runs on a single core (which, let’s
face is, is more than enough processing power for 99\% of your work).
NanoStream sets up each step in your pipeline in its own thread, so
there are no bottlenecks. It monitors all the threads and queues, and
logs any problems. If the data comes in faster than NanoStream can
handle, it applies back-pressure to the data stream. But in reality,
because NanoStream doesn’t have any of the overhead of distributed
systems, it’s pretty fast.


\subsection{Using NanoStream}
\label{\detokenize{overview:using-nanostream}}
You use NanoStream by specifying one or more \sphinxcode{\sphinxupquote{NanoNode}} objects,
linking them together into a pipeline (an acyclic directed graph), and
starting them. Several \sphinxcode{\sphinxupquote{NanoNode}} classes are provided, and it’s easy
to create new ones. Here are some types of examples:


\section{Using built-in \sphinxstyleliteralintitle{\sphinxupquote{NanoNode}} classes}
\label{\detokenize{overview:using-built-in-nanonode-classes}}
Let’s say you want to watch a directory for new CSV files, read them
when they appear, iterate over all the rows, and print those rows as
they arrive. You can do so by importing a few classes, instantiating
them, and running them in a pipeline like so:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Instantiate the classes:}
\PYG{n}{watchdog} \PYG{o}{=} \PYG{n}{LocalDirectoryWatchdog}\PYG{p}{(}\PYG{n}{directory}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{./data\PYGZus{}directory}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{file\PYGZus{}reader} \PYG{o}{=} \PYG{n}{LocalFileReader}\PYG{p}{(}\PYG{n}{serialize}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}
\PYG{n}{csv\PYGZus{}reader} \PYG{o}{=} \PYG{n}{CSVReader}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{printer} \PYG{o}{=} \PYG{n}{PrinterOfThings}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Use \PYGZdq{}\PYGZgt{}\PYGZdq{} to create connections between the nodes}
\PYG{n}{watchdog} \PYG{o}{\PYGZgt{}} \PYG{n}{file\PYGZus{}reader} \PYG{o}{\PYGZgt{}} \PYG{n}{csv\PYGZus{}reader} \PYG{o}{\PYGZgt{}} \PYG{n}{printer}

\PYG{c+c1}{\PYGZsh{} Start it}
\PYG{c+c1}{\PYGZsh{} You can run the {}`global\PYGZus{}start{}` method on any of the connected nodes;}
\PYG{c+c1}{\PYGZsh{} it will automatically start all of them.}
\PYG{n}{watchdog}\PYG{o}{.}\PYG{n}{global\PYGZus{}start}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

The result will be a streaming pipeline that monitors
\sphinxcode{\sphinxupquote{data\_directory/}}, printing the rows of any CSV file that appears
there (or is modified).


\section{Rolling your own \sphinxstyleliteralintitle{\sphinxupquote{NanoNode}} class}
\label{\detokenize{overview:rolling-your-own-nanonode-class}}
\sphinxcode{\sphinxupquote{NanoNode}} objects fall into one of two categories, depending on
whether they ingest data from other nodes, or generate data another way.
If they accept data from an upstream \sphinxcode{\sphinxupquote{NanoNode}}, then you specify a
\sphinxcode{\sphinxupquote{process\_item}} method; if they generate their own data (i.e. they’re
at the beginning of the pipeline), then you specify a \sphinxcode{\sphinxupquote{generator}}
method. Your class should inherit from \sphinxcode{\sphinxupquote{NanoNode}}, and you provide the
appropriate method (\sphinxcode{\sphinxupquote{process\_item}} or \sphinxcode{\sphinxupquote{generator}}), and if
necessary, define an \sphinxcode{\sphinxupquote{\_\_init\_\_}} method.

For example, suppose you want to create a source node for your pipeline
that simply emits the word \sphinxcode{\sphinxupquote{foo}} every few seconds, and the user
specifies how many seconds between each \sphinxcode{\sphinxupquote{foo}}. Then the class would be
defined like so:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{FooEmitter}\PYG{p}{(}\PYG{n}{NanoNode}\PYG{p}{)}\PYG{p}{:}  \PYG{c+c1}{\PYGZsh{} inherit from NanoNode}
    \PYG{k}{def} \PYG{n+nf}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{message}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{interval}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{message} \PYG{o}{=} \PYG{n}{message}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{interval} \PYG{o}{=} \PYG{n}{interval}
        \PYG{n+nb}{super}\PYG{p}{(}\PYG{n}{FooEmitter}\PYG{p}{,} \PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{o}{.}\PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} Must call the {}`NanoNode{}` \PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}

    \PYG{k}{def} \PYG{n+nf}{generator}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{while} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{run\PYGZus{}generator}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
            \PYG{n}{time}\PYG{o}{.}\PYG{n}{sleep}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{interval}\PYG{p}{)}
            \PYG{k}{yield} \PYG{n}{message}  \PYG{c+c1}{\PYGZsh{} Output must be yielded, not returned}
\end{sphinxVerbatim}

Of course, the example is trivial because you generally won’t want to
keep sending the same string over and over again forever. More realistic
uses of this pattern would include reading lines from a file, connecting
to an external API, and so on.

Note that the code inside the \sphinxcode{\sphinxupquote{generator}} function is wrapped inside a
\sphinxcode{\sphinxupquote{while}} loop that tests the value of \sphinxcode{\sphinxupquote{self.run\_generator()}}. You’ll
want to ensure that your generator methods follow the same pattern because

Now let’s suppose you want to create a node that is passed a string as a
message, and returns \sphinxcode{\sphinxupquote{True}} if the message has an even number of
characters, \sphinxcode{\sphinxupquote{False}} otherwise. The class definition would look like
this:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{MessageLengthTester}\PYG{p}{(}\PYG{n}{NanoNode}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{def} \PYG{n+nf}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{c+c1}{\PYGZsh{} No particular initialization required in this example}
        \PYG{n+nb}{super}\PYG{p}{(}\PYG{n}{MessageLengthTester}\PYG{p}{,} \PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{o}{.}\PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{p}{)}

    \PYG{k}{def} \PYG{n+nf}{process\PYGZus{}item}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{message}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{if} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{message}\PYG{p}{)} \PYG{o}{\PYGZpc{}} \PYG{l+m+mi}{2} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{:}
            \PYG{k}{yield} \PYG{k+kc}{True}  \PYG{c+c1}{\PYGZsh{} Again, note the use of yield instead of return}
        \PYG{k}{else}\PYG{p}{:}
            \PYG{k}{yield} \PYG{k+kc}{False}
\end{sphinxVerbatim}

That’s it.

Instantiating both of them into a pipeline is just a matter of
instantiating the classes and hooking them together:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{message\PYGZus{}node} \PYG{o}{=} \PYG{n}{FooEmitter}\PYG{p}{(}\PYG{n}{message}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{foobar}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{interval}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{n}{length\PYGZus{}tester\PYGZus{}node} \PYG{o}{=} \PYG{n}{MessageLengthTester}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{message\PYGZus{}node} \PYG{o}{\PYGZgt{}} \PYG{n}{length\PYGZus{}tester\PYGZus{}node}

\PYG{n}{message\PYGZus{}node}\PYG{o}{.}\PYG{n}{global\PYGZus{}start}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}


\section{Composing and configuring \sphinxstyleliteralintitle{\sphinxupquote{NanoNode}} objects}
\label{\detokenize{overview:composing-and-configuring-nanonode-objects}}
Let’s suppose you’ve worked very hard to create the pipeline from the
last example. Now, your boss says that another engineering team wants to
use it, but they want to rename parameters and “freeze” the values of
certain other parameters to specific values. Once that’s done, they want
to use it as just one part of a more complicated \sphinxcode{\sphinxupquote{NanoStream}}
pipeline.

This can be accomplished using a configuration file. When \sphinxcode{\sphinxupquote{NanoStream}}
parses the configuration file, it will dynamically create the desired
class, which can be instantiated and used as if it were a single node in
another pipeline.

The configuration file is written in YAML, and it would look like this:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{name}\PYG{p}{:} \PYG{n}{FooMessageTester}

\PYG{n}{nodes}\PYG{p}{:}
  \PYG{o}{\PYGZhy{}} \PYG{n}{name}\PYG{p}{:} \PYG{n}{foo\PYGZus{}generator}
    \PYG{k}{class} \PYG{n+nc}{FooEmitter}
    \PYG{n}{frozen\PYGZus{}arguments}\PYG{p}{:}
      \PYG{n}{message}\PYG{p}{:} \PYG{n}{foobar}
    \PYG{n}{arg\PYGZus{}mapping}\PYG{p}{:}
      \PYG{n}{interval}\PYG{p}{:} \PYG{n}{foo\PYGZus{}interval}
  \PYG{o}{\PYGZhy{}} \PYG{n}{name}\PYG{p}{:} \PYG{n}{length\PYGZus{}tester}
    \PYG{n}{class}\PYG{p}{:} \PYG{n}{MessageLengthTester}
    \PYG{n}{arg\PYGZus{}mapping}\PYG{p}{:} \PYG{n}{null}
\end{sphinxVerbatim}

With this file saved as (e.g.) \sphinxcode{\sphinxupquote{foo\_message.yaml}}, the following code
will create a \sphinxcode{\sphinxupquote{FooMessageTester}} class and instantiate it:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{foo\PYGZus{}message\PYGZus{}config} \PYG{o}{=} \PYG{n}{yaml}\PYG{o}{.}\PYG{n}{load}\PYG{p}{(}\PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{./foo\PYGZus{}message.yaml}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{class\PYGZus{}factory}\PYG{p}{(}\PYG{n}{foo\PYGZus{}message\PYGZus{}config}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} At this point, there is now a {}`FooMessageTester{}` class}
\PYG{n}{foo\PYGZus{}node} \PYG{o}{=} \PYG{n}{FooMessageTester}\PYG{p}{(}\PYG{n}{foo\PYGZus{}interval}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
\end{sphinxVerbatim}

You can now use \sphinxcode{\sphinxupquote{foo\_node}} just as you would any other node. So in
order to run it, you just do:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{foo\PYGZus{}node}\PYG{o}{.}\PYG{n}{global\PYGZus{}start}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

Because \sphinxcode{\sphinxupquote{foo\_node}} is just another node, you can insert it into a
larger pipeline and reuse it. For example, suppose that other
engineering team wants to add a \sphinxcode{\sphinxupquote{PrinterOfThings}} to the end of the
pipeline. They’d do this:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{printer} \PYG{o}{=} \PYG{n}{PrinterOfThings}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{foo\PYGZus{}node} \PYG{o}{\PYGZgt{}} \PYG{n}{printer}
\end{sphinxVerbatim}


\chapter{Requirements}
\label{\detokenize{requirements:requirements}}\label{\detokenize{requirements::doc}}
NanoStream is written in Python 3.5. All requirements are pip-installable and
are listed n the \sphinxcode{\sphinxupquote{requirements.txt}} file:

\sphinxcode{\sphinxupquote{{}`
pip install -r requirements.txt
{}`}}

The documentation is written using Sphinx, so if you want to rebuild the docs,
you’ll do:

\sphinxcode{\sphinxupquote{{}`
make {[}html \textbar{} latexpdf \textbar{} whatever{]}
{}`}}

That ought to be everything.


\chapter{Implementation}
\label{\detokenize{implementation:implementation}}\label{\detokenize{implementation::doc}}
Nothing here yet.


\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\DUrole{xref,std,std-ref}{search}

\end{itemize}



\renewcommand{\indexname}{Index}
\printindex
\end{document}