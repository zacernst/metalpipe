================
The Data Journey
================

Overview
--------

NanoStream pipelines create dictionary-like objects as messages, and those
messages move through the various nodes until they reach a sink. As they move
through the nodes, they are modified in one or more of the following ways:

1. New keys and values are added to the dictionary.
#. Keys and values are removed from the dictionary.
#. Values are modified through in-place operations.
#. The structure of the dictionary is changed (e.g. keys are renamed, the
   dictionary is flattened, and so on).

Which of these operations is used depends on the particular type of node that
processes the message, and how the various options are specified for that
node.

By default, each time a message is processed, all of its existing keys and
values are retained in the message as it's passed to the next node. This
behavior is to enable the message to accumulate information over several steps
in the pipeline because some nodes require data that is generated by various
operations.

Nodes may have access to the entire message, or it is possible to specify
which key-value pair is passed to it. This is done by using the ``key``
option in the node definition. If the node will be generating results to be
passed downstream, then we need to either (1) specify the output key for those results; or
(2) make sure that the node is generating a dictionary. If (2), then by default
the dictionary will be merged into the incoming message, and the
combined dictionary will be placed on the node's outgoing queue. If a specific
key is specified for the generated data, then we use the ``output_key``
option in the node definition.

Example: Making a GET request
-----------------------------

Let's consider a very common ETL task. We want to make a GET request to an
API endpoint and return the result. The GET request will take a couple of
parameters, such as an endpoint name, date and username. For our example, 
the URL will just be:

::

       http://example.api.com/ENDPOINT?date=DATE&username=USERNAME


As you would expect, the username and endpoint can be specified in advance;
but the date will change each time the pipeline is run. So the date has to
be generated at runtime and passed to the node. In our example, the
date will be passed to the pipeline as an environment variables ``DATE``
when the pipeline is executed.

NanoNode contains node classes for reading environment variables and for making
GET requests. They are called ``GetEnvironmentVariables`` and
``HttpGetRequest``. They take the following options:

1. ``GetEnvironmentVariables``

   * ``environment_variables``: A list of the names of the environment
     variables to be fetched. The results will be put in keys named after
     those environment variables.

#. ``HttpGetRequest``

   * ``url`` (required): The URL for the GET request. Any parameters that will be filled-in
     at runtime should be put into curly braces. See the example configuration
     file below.
   * ``json`` (optional: default ``True``) Whether the response should be parsed as JSON.
   * ``endpoint_dict`` (optional) Keys and values to be substituted into the
     url.


